Subject: [PATCH] Add type-length-value library
---
Index: Cargo.lock
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Cargo.lock b/Cargo.lock
--- a/Cargo.lock	(revision b76028cd0285f2b2f5585c8bb34c5d253e662e83)
+++ b/Cargo.lock	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
@@ -136,9 +136,9 @@

 [[package]]
 name = "arrayref"
-version = "0.3.6"
+version = "0.3.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a4c527152e37cf757a3f78aae5a06fbeefdb07ccc535c980a3208ee3060dd544"
+checksum = "6b4930d2cb77ce62f89ee5d5289b4ac049559b1c45539271f5ed4fdc7db34545"

 [[package]]
 name = "arrayvec"
@@ -174,8 +174,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "726535892e8eae7e70657b4c8ea93d26b8553afb1ce617caee529ef96d7dee6c"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
  "synstructure",
 ]
@@ -186,8 +186,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2777730b2039ac0f95f093556e61b6d26cebed5393ca6f152717777cec3a42ed"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -250,8 +250,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "10f203db73a71dfa2fb6dd22763990fa26f3d2625a6da2da900d23b87d26be27"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -261,8 +261,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "76464446b8bc32758d7e88ee1a804d9914cd9b1cb264c029899680b0be29826f"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -402,8 +402,8 @@
  "lazy_static",
  "lazycell",
  "peeking_take_while",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "regex",
  "rustc-hash",
  "shlex",
@@ -518,7 +518,7 @@
  "borsh-derive-internal",
  "borsh-schema-derive-internal",
  "proc-macro-crate 0.1.5",
- "proc-macro2 1.0.43",
+ "proc-macro2 1.0.58",
  "syn 1.0.99",
 ]

@@ -528,8 +528,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5449c28a7b352f2d1e592a8a28bf139bc71afb0764a14f3c02500935d8c44065"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -539,8 +539,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "cdbd5696d8bfa21d53d9fe39a714a18538bad11492a42d066dbbc395fb1951c0"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -606,22 +606,22 @@

 [[package]]
 name = "bytemuck"
-version = "1.12.1"
+version = "1.13.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2f5715e491b5a1598fc2bef5a606847b5dc1d48ea625bd3c02c00de8285591da"
+checksum = "17febce684fd15d89027105661fec94afb475cb995fbc59d2865198446ba2eea"
 dependencies = [
  "bytemuck_derive",
 ]

 [[package]]
 name = "bytemuck_derive"
-version = "1.2.1"
+version = "1.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1b9e1f5fa78f69496407a27ae9ed989e3c3b072310286f5ef385525e4cbc24a9"
+checksum = "fdde5c9cd29ebd706ce1b35600920a33550e402fc998a2e53ad3b42c3c47a192"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
- "syn 1.0.99",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
+ "syn 2.0.16",
 ]

 [[package]]
@@ -678,8 +678,8 @@
  "heck 0.3.3",
  "indexmap",
  "log",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "serde",
  "serde_json",
  "syn 1.0.99",
@@ -1055,8 +1055,8 @@
  "cc",
  "codespan-reporting",
  "once_cell",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "scratch",
  "syn 1.0.99",
 ]
@@ -1073,8 +1073,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "309e4fb93eed90e1e14bea0da16b209f81813ba9fc7830c20ed151dd7bc0a4d7"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -1096,8 +1096,8 @@
 dependencies = [
  "fnv",
  "ident_case",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "strsim 0.10.0",
  "syn 1.0.99",
 ]
@@ -1109,7 +1109,7 @@
 checksum = "9c972679f83bdf9c42bd905396b6c3588a843a17f0f16dfcfa3e2c5d57441835"
 dependencies = [
  "darling_core",
- "quote 1.0.21",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -1165,8 +1165,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b24629208e87a2d8b396ff43b15c4afb0a69cea3fbbaa9ed9b92b7c02f0aed73"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -1177,8 +1177,8 @@
 checksum = "4fb810d30a7c1953f91334de7244731fc3f3c10d7fe163338a35b9f640960321"
 dependencies = [
  "convert_case",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "rustc_version",
  "syn 1.0.99",
 ]
@@ -1265,8 +1265,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3bf95dc3f046b9da4f2d51833c0d3547d8564ef6910f5c1ed130306a75b92886"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -1347,8 +1347,8 @@
 checksum = "f86b50932a01e7ec5c06160492ab660fb19b6bb2a7878030dd6cd68d21df9d4d"
 dependencies = [
  "enum-ordinalize",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -1388,8 +1388,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8958699f9359f0b04e691a13850d48b7de329138023876d07cbd024c2c820598"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -1401,8 +1401,8 @@
 dependencies = [
  "num-bigint 0.4.3",
  "num-traits",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -1413,8 +1413,8 @@
 checksum = "0eb359f1476bf611266ac1f5355bc14aeca37b299d0ebccc038ee7058891c9cb"
 dependencies = [
  "once_cell",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -1638,8 +1638,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "42cd15d1c7456c04dbdf7e88bcd69760d74f3a798d6444e16974b505b0e62f17"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -2293,8 +2293,8 @@
 checksum = "5b939a78fa820cdfcb7ee7484466746a7377760970f6f9c6fe19f9edcc8a38d2"
 dependencies = [
  "proc-macro-crate 0.1.5",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -2681,8 +2681,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5a7d5f7076603ebc68de2dc6a650ec331a062a13abaa346975be747bbfa4b789"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -2836,8 +2836,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "876a53fff98e03a936a674b29568b0e605f06b29372c2489ff4de23f1949743d"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -2900,7 +2900,16 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "cf5395665662ef45796a4ff5486c5d41d29e0c09640af4c5f17fd94ee2c119c9"
 dependencies = [
- "num_enum_derive",
+ "num_enum_derive 0.5.7",
+]
+
+[[package]]
+name = "num_enum"
+version = "0.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a015b430d3c108a207fd776d2e2196aaf8b1cf8cf93253e3a097ff3085076a1"
+dependencies = [
+ "num_enum_derive 0.6.1",
 ]

 [[package]]
@@ -2910,11 +2919,23 @@
 checksum = "3b0498641e53dd6ac1a4f22547548caa6864cc4933784319cd1775271c5a46ce"
 dependencies = [
  "proc-macro-crate 1.1.0",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

+[[package]]
+name = "num_enum_derive"
+version = "0.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "96667db765a921f7b295ffee8b60472b686a51d4f21c2ee4ffdb94c7013b65a6"
+dependencies = [
+ "proc-macro-crate 1.1.0",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
+ "syn 2.0.16",
+]
+
 [[package]]
 name = "num_threads"
 version = "0.1.5"
@@ -3043,8 +3064,8 @@
 dependencies = [
  "Inflector",
  "proc-macro-error",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -3177,8 +3198,8 @@
 dependencies = [
  "pest",
  "pest_meta",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -3218,8 +3239,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b95af56fee93df76d721d356ac1ca41fccf168bc448eb14049234df764ba3e76"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -3315,7 +3336,7 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3b83ec2d0af5c5c556257ff52c9f98934e243b9fd39604bfb2a9b75ec2e97f18"
 dependencies = [
- "proc-macro2 1.0.43",
+ "proc-macro2 1.0.58",
  "syn 1.0.99",
 ]

@@ -3345,8 +3366,8 @@
 checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
 dependencies = [
  "proc-macro-error-attr",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
  "version_check",
 ]
@@ -3357,8 +3378,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "version_check",
 ]

@@ -3373,9 +3394,9 @@

 [[package]]
 name = "proc-macro2"
-version = "1.0.43"
+version = "1.0.58"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0a2ca2c61bc9f3d74d2886294ab7b9853abd9c1ad903a3ac7815c58989bb7bab"
+checksum = "fa1fb82fc0c281dd9671101b66b771ebbe1eaf967b96ac8740dcba4b70005ca8"
 dependencies = [
  "unicode-ident",
 ]
@@ -3468,8 +3489,8 @@
 dependencies = [
  "anyhow",
  "itertools",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -3481,8 +3502,8 @@
 dependencies = [
  "anyhow",
  "itertools",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -3601,11 +3622,11 @@

 [[package]]
 name = "quote"
-version = "1.0.21"
+version = "1.0.27"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbe448f377a7d6961e30f5955f9b8d106c3f5e449d493ee1b125c1d43c2b5179"
+checksum = "8f4f29d145265ec1c483c7c654450edde0bfe043d3938d6972630663356d9500"
 dependencies = [
- "proc-macro2 1.0.43",
+ "proc-macro2 1.0.58",
 ]

 [[package]]
@@ -4051,8 +4072,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bdbda6ac5cd1321e724fa9cee216f3a61885889b896f073b8f82322789c5250e"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -4129,8 +4150,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d3d8e8de557aee63c26b85b947f5e59b690d0454c753f3adeb5cd7835ab88391"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -4174,8 +4195,8 @@
 checksum = "e182d6ec6f05393cc0e5ed1bf81ad6db3a8feedf8ee515ecdd369809bcce8082"
 dependencies = [
  "darling",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -4221,8 +4242,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b2acd6defeddb41eb60bb468f8825d0cfd0c2a76bc03bfd235b6a1dc4f6a1ad5"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -4233,8 +4254,8 @@
 checksum = "f1b95bb2f4f624565e8fe8140c789af7e2082c0e0561b5a82a1b678baa9703dc"
 dependencies = [
  "proc-macro-error",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "rustversion",
  "syn 1.0.99",
 ]
@@ -4336,8 +4357,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5dd835154aa943dfc958f5a208f2e82b7d2a2c52b024229168c211ecc2d2bfd1"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "shank_macro_impl",
  "syn 1.0.99",
 ]
@@ -4349,8 +4370,8 @@
 checksum = "d99ad9d5137704e86e2e4a54a121b9c443c37b60ce6638a7723ab700dbd2232a"
 dependencies = [
  "anyhow",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "serde",
  "syn 1.0.99",
 ]
@@ -4783,7 +4804,7 @@
  "log",
  "lru",
  "min-max-heap",
- "num_enum",
+ "num_enum 0.5.7",
  "rand 0.7.3",
  "rand_chacha 0.2.2",
  "rayon",
@@ -4909,8 +4930,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "be23cc7a382f54dfe1348edb94610e5cc146b8eb21563cdd04062a403c75ba62"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "rustc_version",
  "syn 1.0.99",
 ]
@@ -5016,7 +5037,7 @@
  "log",
  "lru",
  "num_cpus",
- "num_enum",
+ "num_enum 0.5.7",
  "prost 0.11.0",
  "rand 0.7.3",
  "rand_chacha 0.2.2",
@@ -5471,8 +5492,8 @@
 checksum = "33d0acbad862093ea123f3a27364336dcb0c8373522cd6810496a34e932c56c1"
 dependencies = [
  "bs58",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "rustversion",
  "syn 1.0.99",
 ]
@@ -6063,7 +6084,7 @@
 name = "spl-instruction-padding"
 version = "0.1.0"
 dependencies = [
- "num_enum",
+ "num_enum 0.5.7",
  "solana-program",
  "solana-program-test",
  "solana-sdk",
@@ -6175,7 +6196,7 @@
  "mpl-token-metadata",
  "num-derive",
  "num-traits",
- "num_enum",
+ "num_enum 0.5.7",
  "proptest",
  "serde",
  "serde_derive",
@@ -6224,7 +6245,7 @@
  "lazy_static",
  "num-derive",
  "num-traits",
- "num_enum",
+ "num_enum 0.5.7",
  "proptest",
  "serial_test 0.5.1",
  "solana-program",
@@ -6243,7 +6264,7 @@
  "bytemuck",
  "num-derive",
  "num-traits",
- "num_enum",
+ "num_enum 0.5.7",
  "solana-program",
  "thiserror",
 ]
@@ -6257,7 +6278,7 @@
  "lazy_static",
  "num-derive",
  "num-traits",
- "num_enum",
+ "num_enum 0.5.7",
  "proptest",
  "serde",
  "serde_json",
@@ -6282,7 +6303,7 @@
  "bytemuck",
  "num-derive",
  "num-traits",
- "num_enum",
+ "num_enum 0.5.7",
  "solana-program",
  "solana-zk-token-sdk",
  "spl-memo 3.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -6431,7 +6452,7 @@
 dependencies = [
  "num-derive",
  "num-traits",
- "num_enum",
+ "num_enum 0.5.7",
  "solana-program",
  "solana-program-test",
  "solana-sdk",
@@ -6464,6 +6485,20 @@
  "walkdir",
 ]

+[[package]]
+name = "spl-type-length-value"
+version = "0.1.0"
+dependencies = [
+ "arrayref",
+ "borsh",
+ "bytemuck",
+ "num-derive",
+ "num-traits",
+ "num_enum 0.6.1",
+ "solana-program",
+ "thiserror",
+]
+
 [[package]]
 name = "stateless-asks"
 version = "0.1.0"
@@ -6523,8 +6558,8 @@
 checksum = "6878079b17446e4d3eba6192bb0a2950d5b14f0ed8424b852310e5a94345d0ef"
 dependencies = [
  "heck 0.4.0",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "rustversion",
  "syn 1.0.99",
 ]
@@ -6558,8 +6593,19 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "58dbef6ec655055e20b86b15a8cc6d439cca19b667537ac6a1369572d151ab13"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
+ "unicode-ident",
+]
+
+[[package]]
+name = "syn"
+version = "2.0.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a6f671d4b5ffdb8eadec19c0ae67fe2639df8684bd7bc4b83d986b8db549cf01"
+dependencies = [
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "unicode-ident",
 ]

@@ -6575,8 +6621,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f36bdaa60a83aca3921b5259d5400cbf5e90fc51931376a9bd4a0eb79aa7210f"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
  "unicode-xid 0.2.2",
 ]
@@ -6645,8 +6691,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0ee42b4e559f17bce0385ebf511a7beb67d5cc33c12c96b7f4e9789919d9c10f"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -6706,8 +6752,8 @@
 dependencies = [
  "cfg-if 1.0.0",
  "proc-macro-error",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -6751,8 +6797,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "12bafc5b54507e0149cdf1b145a5d80ab80a90bcd9275df43d4fff68460f6c21"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -6864,8 +6910,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b557f72f448c511a979e2564e55d74e6c4432fc96ff4f6241bc6bded342643b7"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -7055,9 +7101,9 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9403f1bafde247186684b230dc6f38b5cd514584e8bec1dd32514be4745fa757"
 dependencies = [
- "proc-macro2 1.0.43",
+ "proc-macro2 1.0.58",
  "prost-build 0.9.0",
- "quote 1.0.21",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -7068,9 +7114,9 @@
 checksum = "2fbcd2800e34e743b9ae795867d5f77b535d3a3be69fd731e39145719752df8c"
 dependencies = [
  "prettyplease",
- "proc-macro2 1.0.43",
+ "proc-macro2 1.0.58",
  "prost-build 0.11.1",
- "quote 1.0.21",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -7144,8 +7190,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f4f480b8f81512e825f337ad51e94c1eb5d3bbdf2b363dcd01e2b19a9ffe3f8e"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
 ]

@@ -7472,8 +7518,8 @@
  "bumpalo",
  "log",
  "once_cell",
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
  "wasm-bindgen-shared",
 ]
@@ -7496,7 +7542,7 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b260f13d3012071dfb1512849c033b1925038373aea48ced3012c09df952c602"
 dependencies = [
- "quote 1.0.21",
+ "quote 1.0.27",
  "wasm-bindgen-macro-support",
 ]

@@ -7506,8 +7552,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5be8e654bdd9b79216c2929ab90721aa82faf65c48cdf08bdc4e7f51357b80da"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
@@ -7724,8 +7770,8 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "65f1a51723ec88c66d5d1fe80c841f17f63587d6691901d66be9bec6c3b51f73"
 dependencies = [
- "proc-macro2 1.0.43",
- "quote 1.0.21",
+ "proc-macro2 1.0.58",
+ "quote 1.0.27",
  "syn 1.0.99",
  "synstructure",
 ]
Index: Cargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Cargo.toml b/Cargo.toml
--- a/Cargo.toml	(revision b76028cd0285f2b2f5585c8bb34c5d253e662e83)
+++ b/Cargo.toml	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
@@ -22,6 +22,7 @@
   "libraries/math",
   "libraries/concurrent-merkle-tree",
   "libraries/merkle-tree-reference",
+  "libraries/type-length-value",
   "memo/program",
   "name-service/program",
   "managed-token/program",
Index: libraries/type-length-value/Cargo.toml
===================================================================
diff --git a/libraries/type-length-value/Cargo.toml b/libraries/type-length-value/Cargo.toml
new file mode 100644
--- /dev/null	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
+++ b/libraries/type-length-value/Cargo.toml	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
@@ -0,0 +1,28 @@
+[package]
+name = "spl-type-length-value"
+version = "0.1.0"
+description = "Solana Program Library Type-Length-Value Management"
+authors = ["Solana Labs Maintainers <maintainers@solanalabs.com>"]
+repository = "https://github.com/solana-labs/solana-program-library"
+license = "Apache-2.0"
+edition = "2021"
+exclude = ["js/**"]
+
+[features]
+borsh = ["dep:borsh"]
+
+[dependencies]
+arrayref = "0.3.7"
+borsh = { version = "0.9.1", optional = true }
+bytemuck = { version = "1.13.1", features = ["derive"] }
+num-derive = "0.3"
+num-traits = "0.2"
+num_enum = "0.6.1"
+solana-program = "1.14.12"
+thiserror = "1.0"
+
+[lib]
+crate-type = ["cdylib", "lib"]
+
+[package.metadata.docs.rs]
+targets = ["x86_64-unknown-linux-gnu"]
Index: libraries/type-length-value/README.md
===================================================================
diff --git a/libraries/type-length-value/README.md b/libraries/type-length-value/README.md
new file mode 100644
--- /dev/null	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
+++ b/libraries/type-length-value/README.md	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
@@ -0,0 +1,147 @@
+# Type-Length-Value
+
+Library with utilities for working with Type-Length-Value structures.
+
+## Example usage
+
+This simple examples defines a zero-copy type with its discriminator.
+
+```rust
+use {
+    borsh::{BorshSerialize, BorshDeserialize},
+    bytemuck::{Pod, Zeroable},
+    spl_type_length_value::{
+        discriminator::{Discriminator, TlvDiscriminator},
+        state::{TlvState, TlvStateBorrowed, TlvStateMut}
+    },
+};
+
+#[repr(C)]
+#[derive(Clone, Copy, Debug, Default, PartialEq, Pod, Zeroable)]
+struct MyPodValue {
+    data: [u8; 32],
+}
+impl TlvDiscriminator for MyPodValue {
+    // Give it a unique discriminator, can also be generated using a hash function
+    const TLV_DISCRIMINATOR: Discriminator = Discriminator::new([1; Discriminator::LENGTH]);
+}
+#[repr(C)]
+#[derive(Clone, Copy, Debug, PartialEq, Pod, Zeroable)]
+struct MyOtherPodValue {
+    data: u8,
+}
+// Give this type a non-derivable implementation of `Default` to write some data
+impl Default for MyOtherPodValue {
+    fn default() -> Self {
+        Self {
+            data: 10,
+        }
+    }
+}
+impl TlvDiscriminator for MyOtherPodValue {
+    // Some other unique discriminator
+    const TLV_DISCRIMINATOR: Discriminator = Discriminator::new([2; Discriminator::LENGTH]);
+}
+
+// Account will have two sets of `get_base_len()` (8-byte discriminator and 4-byte length),
+// and enough room for a `MyPodValue` and a `MyOtherPodValue`
+let account_size = TlvState::get_base_len() + std::mem::size_of::<MyPodValue>() + \
+    TlvState::get_base_len() + std::mem::size_of::<MyOtherPodValue>();
+
+// Buffer likely comes from a Solana `solana_program::account_info::AccountInfo`,
+// but this example just uses a vector.
+let mut buffer = vec![0; account_size];
+
+// Unpack the base buffer as a TLV structure
+let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+
+// Init and write default value
+let value = state.init_value::<MyPodValue>().unwrap();
+// Update it in-place
+value.data[0] = 1;
+
+// Init and write another default value
+let other_value = state.init_value::<MyOtherPodValue>().unwrap();
+assert_eq!(other_value.data, 10);
+// Update it in-place
+other_value.data = 2;
+
+// Later on, to work with it again
+let value = state.get_value_mut::<MyPodValue>().unwrap();
+
+// Or fetch it from an immutable buffer
+let state = TlvStateBorrowed::unpack(&buffer).unwrap();
+let value = state.get_value::<MyOtherPodValue>().unwrap();
+```
+
+## Motivation
+
+The Solana blockchain exposes slabs of bytes to on-chain programs, allowing program
+writers to intepret these bytes and change them however they wish. Currently,
+programs interpet account bytes as being only of one type. For example, an token
+mint account is only ever a token mint, an AMM pool account is only ever an AMM pool,
+a token metadata account can only hold token metadata, etc.
+
+In a world of interfaces, a program will likely implement multiple interfaces.
+As a concrete and important example, imagine a token program where mints hold
+their own metadata. This means that a single account can be both a mint and
+metadata.
+
+To allow easy implementation of multiple interfaces, accounts must be able to
+hold multiple different types within one opaque slab of bytes. The
+[type-length-value](https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value)
+scheme facilitates this exact case.
+
+## How it works
+
+This library allows for holding multiple disparate types within the same account
+by encoding the type, then length, then value.
+
+The type is an 8-byte `Discriminator`, which can be set to anything.
+
+The length is a little-endian `u32`.
+
+The value is a slab of `length` bytes that can be used however a program desires.
+
+When searching through the buffer for a particular type, the library looks at
+the first 8-byte discriminator. If it's all zeroes, this means it's uninitialized.
+If not, it reads the next 4-byte length. If the discriminator matches, it returns
+the next `length` bytes. If not, it jumps ahead `length` bytes and reads the
+next 8-byte discriminator.
+
+## Borsh integration
+
+The initial example works using the `bytemuck` crate for zero-copy serialization
+and deserialization. It's possible to use Borsh by activating the `borsh` feature.
+
+```rust
+use {
+    borsh::{BorshDeserialize, BorshSerialize},
+    spl_type_length_value::state::{TlvState, TlvStateMut},
+};
+#[derive(Clone, Debug, PartialEq, BorshDeserialize, BorshSerialize)]
+struct MyBorsh {
+    data: String, // variable length type
+}
+impl TlvDiscriminator for MyBorsh {
+    const TLV_DISCRIMINATOR: Discriminator = Discriminator::new([5; Discriminator::LENGTH]);
+}
+let initial_data = "This is a pretty cool test!";
+// Allocate exactly the right size for the string, can go bigger if desired
+let tlv_size = 4 + initial_data.len();
+let account_size = TlvState::get_base_len() + tlv_size;
+
+// Buffer likely comes from a Solana `solana_program::account_info::AccountInfo`,
+// but this example just uses a vector.
+let mut buffer = vec![0; account_size];
+let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+
+// No need to hold onto the bytes since we'll serialize back into the right place
+let _ = state.allocate::<MyBorsh>(tlv_size).unwrap();
+let my_borsh = MyBorsh {
+    data: initial_data.to_string()
+};
+state.borsh_serialize(&my_borsh).unwrap();
+let deser = state.borsh_deserialize::<MyBorsh>().unwrap();
+assert_eq!(deser, my_borsh);
+```
Index: libraries/type-length-value/src/discriminator.rs
===================================================================
diff --git a/libraries/type-length-value/src/discriminator.rs b/libraries/type-length-value/src/discriminator.rs
new file mode 100644
--- /dev/null	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
+++ b/libraries/type-length-value/src/discriminator.rs	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
@@ -0,0 +1,59 @@
+//! Discriminator for differentiating account types, the "Type" in the
+//! Type-Length-Value structure. Since the word "type" is reserved in Rust,
+//! we use the term "Discriminator" and "Type" interchangeably.
+
+use {
+    bytemuck::{Pod, Zeroable},
+    solana_program::program_error::ProgramError,
+};
+
+/// Trait to be implemented by all value types in the TLV structure, specifying
+/// just the discriminator
+pub trait TlvDiscriminator {
+    /// Associated value type discriminator, checked at the start of TLV entries
+    const TLV_DISCRIMINATOR: Discriminator;
+}
+
+/// Discriminator used as the type in the TLV structure
+/// Type in TLV structure
+#[derive(Clone, Copy, Debug, Default, PartialEq, Pod, Zeroable)]
+#[repr(transparent)]
+pub struct Discriminator([u8; Discriminator::LENGTH]);
+impl Discriminator {
+    /// Size for discriminator in account data
+    pub const LENGTH: usize = 8;
+    /// Uninitialized variant of a discriminator
+    pub const UNINITIALIZED: Self = Self::new([0; Self::LENGTH]);
+    /// Creates a discriminator from an array
+    pub const fn new(value: [u8; Self::LENGTH]) -> Self {
+        Self(value)
+    }
+}
+impl AsRef<[u8]> for Discriminator {
+    fn as_ref(&self) -> &[u8] {
+        &self.0[..]
+    }
+}
+impl AsRef<[u8; Discriminator::LENGTH]> for Discriminator {
+    fn as_ref(&self) -> &[u8; Discriminator::LENGTH] {
+        &self.0
+    }
+}
+impl From<u64> for Discriminator {
+    fn from(from: u64) -> Self {
+        Self(from.to_le_bytes())
+    }
+}
+impl From<[u8; Self::LENGTH]> for Discriminator {
+    fn from(from: [u8; Self::LENGTH]) -> Self {
+        Self(from)
+    }
+}
+impl TryFrom<&[u8]> for Discriminator {
+    type Error = ProgramError;
+    fn try_from(a: &[u8]) -> Result<Self, Self::Error> {
+        <[u8; Self::LENGTH]>::try_from(a)
+            .map(Self::from)
+            .map_err(|_| ProgramError::InvalidAccountData)
+    }
+}
Index: libraries/type-length-value/src/error.rs
===================================================================
diff --git a/libraries/type-length-value/src/error.rs b/libraries/type-length-value/src/error.rs
new file mode 100644
--- /dev/null	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
+++ b/libraries/type-length-value/src/error.rs	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
@@ -0,0 +1,48 @@
+//! Error types
+
+use {
+    num_derive::FromPrimitive,
+    solana_program::{
+        decode_error::DecodeError,
+        msg,
+        program_error::{PrintProgramError, ProgramError},
+    },
+    thiserror::Error,
+};
+
+/// Errors that may be returned by the Token program.
+#[derive(Clone, Debug, Eq, Error, FromPrimitive, PartialEq)]
+pub enum TlvError {
+    // 0
+    /// Type not found in TLV data
+    #[error("Type not found in TLV data")]
+    TypeNotFound,
+    /// Type already exists in TLV data
+    #[error("Type already exists in TLV data")]
+    TypeAlreadyExists,
+}
+impl From<TlvError> for ProgramError {
+    fn from(e: TlvError) -> Self {
+        ProgramError::Custom(e as u32)
+    }
+}
+impl<T> DecodeError<T> for TlvError {
+    fn type_of() -> &'static str {
+        "TlvError"
+    }
+}
+impl PrintProgramError for TlvError {
+    fn print<E>(&self)
+    where
+        E: 'static
+            + std::error::Error
+            + DecodeError<E>
+            + PrintProgramError
+            + num_traits::FromPrimitive,
+    {
+        match self {
+            Self::TypeNotFound => msg!("Type not found in TLV data"),
+            Self::TypeAlreadyExists => msg!("Type already exists in TLV data"),
+        }
+    }
+}
Index: libraries/type-length-value/src/length.rs
===================================================================
diff --git a/libraries/type-length-value/src/length.rs b/libraries/type-length-value/src/length.rs
new file mode 100644
--- /dev/null	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
+++ b/libraries/type-length-value/src/length.rs	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
@@ -0,0 +1,25 @@
+//! Module for the length portion of a Type-Length-Value structure
+use {
+    crate::pod::PodU32,
+    bytemuck::{Pod, Zeroable},
+    solana_program::program_error::ProgramError,
+};
+
+/// Length in TLV structure
+#[derive(Clone, Copy, Debug, Default, PartialEq, Pod, Zeroable)]
+#[repr(transparent)]
+pub struct Length(PodU32);
+impl TryFrom<Length> for usize {
+    type Error = ProgramError;
+    fn try_from(n: Length) -> Result<Self, Self::Error> {
+        Self::try_from(u32::from(n.0)).map_err(|_| ProgramError::AccountDataTooSmall)
+    }
+}
+impl TryFrom<usize> for Length {
+    type Error = ProgramError;
+    fn try_from(n: usize) -> Result<Self, Self::Error> {
+        u32::try_from(n)
+            .map(|v| Self(PodU32::from(v)))
+            .map_err(|_| ProgramError::AccountDataTooSmall)
+    }
+}
Index: libraries/type-length-value/src/lib.rs
===================================================================
diff --git a/libraries/type-length-value/src/lib.rs b/libraries/type-length-value/src/lib.rs
new file mode 100644
--- /dev/null	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
+++ b/libraries/type-length-value/src/lib.rs	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
@@ -0,0 +1,15 @@
+//! Crate defining an interface for managing type-length-value entries in a slab
+//! of bytes, to be used with Solana accounts.
+
+#![allow(clippy::integer_arithmetic)]
+#![deny(missing_docs)]
+#![cfg_attr(not(test), forbid(unsafe_code))]
+
+pub mod discriminator;
+pub mod error;
+pub mod length;
+pub mod pod;
+pub mod state;
+
+// Export current sdk types for downstream users building with a different sdk version
+pub use solana_program;
Index: libraries/type-length-value/src/pod.rs
===================================================================
diff --git a/libraries/type-length-value/src/pod.rs b/libraries/type-length-value/src/pod.rs
new file mode 100644
--- /dev/null	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
+++ b/libraries/type-length-value/src/pod.rs	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
@@ -0,0 +1,40 @@
+//! Pod types to be used with bytemuck for zero-copy serde
+
+use {
+    bytemuck::{Pod, Zeroable},
+    solana_program::program_error::ProgramError,
+};
+
+/// Convert a slice into a `Pod` (zero copy)
+pub fn pod_from_bytes<T: Pod>(bytes: &[u8]) -> Result<&T, ProgramError> {
+    bytemuck::try_from_bytes(bytes).map_err(|_| ProgramError::InvalidArgument)
+}
+/// Convert a slice into a mutable `Pod` (zero copy)
+pub fn pod_from_bytes_mut<T: Pod>(bytes: &mut [u8]) -> Result<&mut T, ProgramError> {
+    bytemuck::try_from_bytes_mut(bytes).map_err(|_| ProgramError::InvalidArgument)
+}
+
+/// Simple macro for implementing conversion functions between Pod* ints and standard ints.
+///
+/// The standard int types can cause alignment issues when placed in a `Pod`,
+/// so these replacements are usable in all `Pod`s.
+macro_rules! impl_int_conversion {
+    ($P:ty, $I:ty) => {
+        impl From<$I> for $P {
+            fn from(n: $I) -> Self {
+                Self(n.to_le_bytes())
+            }
+        }
+        impl From<$P> for $I {
+            fn from(pod: $P) -> Self {
+                Self::from_le_bytes(pod.0)
+            }
+        }
+    };
+}
+
+/// `u32` type that can be used in `Pod`s
+#[derive(Clone, Copy, Debug, Default, PartialEq, Pod, Zeroable)]
+#[repr(transparent)]
+pub struct PodU32([u8; 4]);
+impl_int_conversion!(PodU32, u32);
Index: libraries/type-length-value/src/state.rs
===================================================================
diff --git a/libraries/type-length-value/src/state.rs b/libraries/type-length-value/src/state.rs
new file mode 100644
--- /dev/null	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
+++ b/libraries/type-length-value/src/state.rs	(revision 89b2adf3b8c31292c0afc2b848196691f229e8bf)
@@ -0,0 +1,895 @@
+//! Type-length-value structure definition and manipulation
+
+use {
+    crate::{
+        discriminator::{Discriminator, TlvDiscriminator},
+        error::TlvError,
+        length::Length,
+        pod::{pod_from_bytes, pod_from_bytes_mut},
+    },
+    bytemuck::Pod,
+    solana_program::program_error::ProgramError,
+    std::{cmp::Ordering, mem::size_of},
+};
+
+/// Get the current TlvIndices from the current spot
+const fn get_indices_unchecked(type_start: usize) -> TlvIndices {
+    let length_start = type_start.saturating_add(size_of::<Discriminator>());
+    let value_start = length_start.saturating_add(size_of::<Length>());
+    TlvIndices {
+        type_start,
+        length_start,
+        value_start,
+    }
+}
+
+/// Internal helper struct for returning the indices of the type, length, and
+/// value in a TLV entry
+#[derive(Debug)]
+struct TlvIndices {
+    pub type_start: usize,
+    pub length_start: usize,
+    pub value_start: usize,
+}
+fn get_indices(
+    tlv_data: &[u8],
+    value_discriminator: Discriminator,
+    init: bool,
+) -> Result<TlvIndices, ProgramError> {
+    let mut start_index = 0;
+    while start_index < tlv_data.len() {
+        let tlv_indices = get_indices_unchecked(start_index);
+        if tlv_data.len() < tlv_indices.value_start {
+            return Err(ProgramError::InvalidAccountData);
+        }
+        let discriminator =
+            Discriminator::try_from(&tlv_data[tlv_indices.type_start..tlv_indices.length_start])?;
+        if discriminator == value_discriminator {
+            // found an instance of the extension that we're initializing, return!
+            return Ok(tlv_indices);
+        // got to an empty spot, init here, or error if we're searching, since
+        // nothing is written after an Uninitialized spot
+        } else if discriminator == Discriminator::UNINITIALIZED {
+            if init {
+                return Ok(tlv_indices);
+            } else {
+                return Err(TlvError::TypeNotFound.into());
+            }
+        } else {
+            let length = pod_from_bytes::<Length>(
+                &tlv_data[tlv_indices.length_start..tlv_indices.value_start],
+            )?;
+            let value_end_index = tlv_indices
+                .value_start
+                .saturating_add(usize::try_from(*length)?);
+            start_index = value_end_index;
+        }
+    }
+    Err(ProgramError::InvalidAccountData)
+}
+
+// This function is doing two separate things at once, and would probably be
+// better served by some custom iterator, but let's leave that for another day.
+fn get_discriminators_and_end_index(
+    tlv_data: &[u8],
+) -> Result<(Vec<Discriminator>, usize), ProgramError> {
+    let mut discriminators = vec![];
+    let mut start_index = 0;
+    while start_index < tlv_data.len() {
+        let tlv_indices = get_indices_unchecked(start_index);
+        if tlv_data.len() < tlv_indices.length_start {
+            // we got to the end, but there might be some uninitialized data after
+            let remainder = &tlv_data[tlv_indices.type_start..];
+            if remainder.iter().all(|&x| x == 0) {
+                return Ok((discriminators, tlv_indices.type_start));
+            } else {
+                return Err(ProgramError::InvalidAccountData);
+            }
+        }
+        let discriminator =
+            Discriminator::try_from(&tlv_data[tlv_indices.type_start..tlv_indices.length_start])?;
+        if discriminator == Discriminator::UNINITIALIZED {
+            return Ok((discriminators, tlv_indices.type_start));
+        } else {
+            if tlv_data.len() < tlv_indices.value_start {
+                // not enough bytes to store the length, malformed
+                return Err(ProgramError::InvalidAccountData);
+            }
+            discriminators.push(discriminator);
+            let length = pod_from_bytes::<Length>(
+                &tlv_data[tlv_indices.length_start..tlv_indices.value_start],
+            )?;
+
+            let value_end_index = tlv_indices
+                .value_start
+                .saturating_add(usize::try_from(*length)?);
+            if value_end_index > tlv_data.len() {
+                // value blows past the size of the slice, malformed
+                return Err(ProgramError::InvalidAccountData);
+            }
+            start_index = value_end_index;
+        }
+    }
+    Ok((discriminators, start_index))
+}
+
+fn get_bytes<V: TlvDiscriminator>(tlv_data: &[u8]) -> Result<&[u8], ProgramError> {
+    let TlvIndices {
+        type_start: _,
+        length_start,
+        value_start,
+    } = get_indices(tlv_data, V::TLV_DISCRIMINATOR, false)?;
+    // get_indices has checked that tlv_data is long enough to include these indices
+    let length = pod_from_bytes::<Length>(&tlv_data[length_start..value_start])?;
+    let value_end = value_start.saturating_add(usize::try_from(*length)?);
+    if tlv_data.len() < value_end {
+        return Err(ProgramError::InvalidAccountData);
+    }
+    Ok(&tlv_data[value_start..value_end])
+}
+
+/// Trait for all TLV state
+///
+/// Stores data as any number of type-length-value structures underneath, where:
+///
+///   * the "type" is a `Discriminator`, 8 bytes
+///   * the "length" is a `Length`, 4 bytes
+///   * the "value" is a slab of "length" bytes
+///
+/// With this structure, it's possible to hold onto any number of entries with
+/// unique discriminators, provided that the total underlying data has enough
+/// bytes for every entry.
+///
+/// For example, if we have two distinct types, one which is an 8-byte array
+/// of value `[0, 1, 0, 0, 0, 0, 0, 0]` and discriminator
+/// `[1, 1, 1, 1, 1, 1, 1, 1]`, and another which is just a single `u8` of value
+/// `4` with the discriminator `[2, 2, 2, 2, 2, 2, 2, 2]`, we can deserialize this
+/// buffer as follows:
+///
+/// ```
+/// use {
+///     bytemuck::{Pod, Zeroable},
+///     spl_type_length_value::{
+///         discriminator::{Discriminator, TlvDiscriminator},
+///         state::{TlvState, TlvStateBorrowed, TlvStateMut}
+///     },
+/// };
+/// #[repr(C)]
+/// #[derive(Clone, Copy, Debug, Default, PartialEq, Pod, Zeroable)]
+/// struct MyPodValue {
+///     data: [u8; 8],
+/// }
+/// impl TlvDiscriminator for MyPodValue {
+///     const TLV_DISCRIMINATOR: Discriminator = Discriminator::new([1; Discriminator::LENGTH]);
+/// }
+/// #[repr(C)]
+/// #[derive(Clone, Copy, Debug, Default, PartialEq, Pod, Zeroable)]
+/// struct MyOtherPodValue {
+///     data: u8,
+/// }
+/// impl TlvDiscriminator for MyOtherPodValue {
+///     const TLV_DISCRIMINATOR: Discriminator = Discriminator::new([2; Discriminator::LENGTH]);
+/// }
+/// let buffer = [
+///   1, 1, 1, 1, 1, 1, 1, 1, // first type's discriminator
+///   8, 0, 0, 0,             // first type's length
+///   0, 1, 0, 0, 0, 0, 0, 0, // first type's value
+///   2, 2, 2, 2, 2, 2, 2, 2, // second type's discriminator
+///   1, 0, 0, 0,             // second type's length
+///   4,                      // second type's value
+/// ];
+/// let state = TlvStateBorrowed::unpack(&buffer).unwrap();
+/// let value = state.get_value::<MyPodValue>().unwrap();
+/// assert_eq!(value.data, [0, 1, 0, 0, 0, 0, 0, 0]);
+/// let value = state.get_value::<MyOtherPodValue>().unwrap();
+/// assert_eq!(value.data, 4);
+/// ```
+///
+/// See the README and tests for more examples on how to use these types.
+pub trait TlvState {
+    /// Get the full buffer containing all TLV data
+    fn get_data(&self) -> &[u8];
+
+    /// Unpack a portion of the TLV data as the desired Pod type
+    fn get_value<V: TlvDiscriminator + Pod>(&self) -> Result<&V, ProgramError> {
+        let data = get_bytes::<V>(self.get_data())?;
+        pod_from_bytes::<V>(data)
+    }
+
+    /// Unpacks a portion of the TLV data as the desired Borsh type
+    #[cfg(feature = "borsh")]
+    fn borsh_deserialize<V: TlvDiscriminator + borsh::BorshDeserialize>(
+        &self,
+    ) -> Result<V, ProgramError> {
+        let data = get_bytes::<V>(self.get_data())?;
+        solana_program::borsh::try_from_slice_unchecked::<V>(data).map_err(Into::into)
+    }
+
+    /// Unpack a portion of the TLV data as bytes
+    fn get_bytes<V: TlvDiscriminator>(&self) -> Result<&[u8], ProgramError> {
+        get_bytes::<V>(self.get_data())
+    }
+
+    /// Iterates through the TLV entries, returning only the types
+    fn get_discriminators(&self) -> Result<Vec<Discriminator>, ProgramError> {
+        get_discriminators_and_end_index(self.get_data()).map(|v| v.0)
+    }
+
+    /// Get the base size required for TLV data
+    fn get_base_len() -> usize {
+        get_base_len()
+    }
+}
+
+/// Encapsulates owned TLV data
+#[derive(Debug, PartialEq)]
+pub struct TlvStateOwned {
+    /// Raw TLV data, deserialized on demand
+    data: Vec<u8>,
+}
+impl TlvStateOwned {
+    /// Unpacks TLV state data
+    ///
+    /// Fails if no state is initialized or if data is too small
+    pub fn unpack(data: Vec<u8>) -> Result<Self, ProgramError> {
+        check_data(&data)?;
+        Ok(Self { data })
+    }
+}
+impl TlvState for TlvStateOwned {
+    fn get_data(&self) -> &[u8] {
+        &self.data
+    }
+}
+
+/// Encapsulates immutable base state data (mint or account) with possible extensions
+#[derive(Debug, PartialEq)]
+pub struct TlvStateBorrowed<'data> {
+    /// Slice of data containing all TLV data, deserialized on demand
+    data: &'data [u8],
+}
+impl<'data> TlvStateBorrowed<'data> {
+    /// Unpacks TLV state data
+    ///
+    /// Fails if no state is initialized or if data is too small
+    pub fn unpack(data: &'data [u8]) -> Result<Self, ProgramError> {
+        check_data(data)?;
+        Ok(Self { data })
+    }
+}
+impl<'a> TlvState for TlvStateBorrowed<'a> {
+    fn get_data(&self) -> &[u8] {
+        self.data
+    }
+}
+
+/// Encapsulates mutable base state data (mint or account) with possible extensions
+#[derive(Debug, PartialEq)]
+pub struct TlvStateMut<'data> {
+    /// Slice of data containing all TLV data, deserialized on demand
+    data: &'data mut [u8],
+}
+impl<'data> TlvStateMut<'data> {
+    /// Unpacks TLV state data
+    ///
+    /// Fails if no state is initialized or if data is too small
+    pub fn unpack(data: &'data mut [u8]) -> Result<Self, ProgramError> {
+        check_data(data)?;
+        Ok(Self { data })
+    }
+
+    /// Unpack a portion of the TLV data as the desired type that allows modifying the type
+    pub fn get_value_mut<V: TlvDiscriminator + Pod>(&mut self) -> Result<&mut V, ProgramError> {
+        let data = self.get_bytes_mut::<V>()?;
+        pod_from_bytes_mut::<V>(data)
+    }
+
+    /// Unpack a portion of the TLV data as mutable bytes
+    pub fn get_bytes_mut<V: TlvDiscriminator>(&mut self) -> Result<&mut [u8], ProgramError> {
+        let TlvIndices {
+            type_start: _,
+            length_start,
+            value_start,
+        } = get_indices(self.data, V::TLV_DISCRIMINATOR, false)?;
+
+        let length = pod_from_bytes::<Length>(&self.data[length_start..value_start])?;
+        let value_end = value_start.saturating_add(usize::try_from(*length)?);
+        if self.data.len() < value_end {
+            return Err(ProgramError::InvalidAccountData);
+        }
+        Ok(&mut self.data[value_start..value_end])
+    }
+
+    /// Packs the default TLV data into the first open slot in the data buffer.
+    /// If extension is already found in the buffer, it returns an error.
+    pub fn init_value<V: TlvDiscriminator + Pod + Default>(
+        &mut self,
+    ) -> Result<&mut V, ProgramError> {
+        let length = size_of::<V>();
+        let buffer = self.alloc::<V>(length)?;
+        let extension_ref = pod_from_bytes_mut::<V>(buffer)?;
+        *extension_ref = V::default();
+        Ok(extension_ref)
+    }
+
+    /// Packs a borsh-serializable value into its appropriate data segment. Assumes
+    /// that space has already been allocated for the given type
+    #[cfg(feature = "borsh")]
+    pub fn borsh_serialize<V: TlvDiscriminator + borsh::BorshSerialize>(
+        &mut self,
+        value: &V,
+    ) -> Result<(), ProgramError> {
+        let data = self.get_bytes_mut::<V>()?;
+        borsh::to_writer(&mut data[..], value).map_err(Into::into)
+    }
+
+    /// Allocate the given number of bytes for the given TlvDiscriminator
+    pub fn alloc<V: TlvDiscriminator>(&mut self, length: usize) -> Result<&mut [u8], ProgramError> {
+        let TlvIndices {
+            type_start,
+            length_start,
+            value_start,
+        } = get_indices(self.data, V::TLV_DISCRIMINATOR, true)?;
+
+        let discriminator = Discriminator::try_from(&self.data[type_start..length_start])?;
+        if discriminator == Discriminator::UNINITIALIZED {
+            // write type
+            let discriminator_ref = &mut self.data[type_start..length_start];
+            discriminator_ref.copy_from_slice(V::TLV_DISCRIMINATOR.as_ref());
+            // write length
+            let length_ref =
+                pod_from_bytes_mut::<Length>(&mut self.data[length_start..value_start])?;
+            *length_ref = Length::try_from(length)?;
+
+            let value_end = value_start.saturating_add(length);
+            if self.data.len() < value_end {
+                return Err(ProgramError::InvalidAccountData);
+            }
+            Ok(&mut self.data[value_start..value_end])
+        } else {
+            Err(TlvError::TypeAlreadyExists.into())
+        }
+    }
+
+    /// Reallocate the given number of bytes for the given TlvDiscriminator. If the new
+    /// length is smaller, it will compact the rest of the buffer and zero out
+    /// the difference at the end. If it's larger, it will move the rest of
+    /// the buffer data and zero out the new data.
+    pub fn realloc<V: TlvDiscriminator>(
+        &mut self,
+        length: usize,
+    ) -> Result<&mut [u8], ProgramError> {
+        let TlvIndices {
+            type_start: _,
+            length_start,
+            value_start,
+        } = get_indices(self.data, V::TLV_DISCRIMINATOR, false)?;
+        let (_, end_index) = get_discriminators_and_end_index(self.data)?;
+        let data_len = self.data.len();
+
+        let length_ref = pod_from_bytes_mut::<Length>(&mut self.data[length_start..value_start])?;
+        let old_length = usize::try_from(*length_ref)?;
+
+        // check that we're not going to panic during `copy_within`
+        if old_length < length {
+            let new_end_index = end_index.saturating_add(length.saturating_sub(old_length));
+            if new_end_index > data_len {
+                return Err(ProgramError::InvalidAccountData);
+            }
+        }
+
+        // write new length after the check, to avoid getting into a bad situation
+        // if trying to recover from an error
+        *length_ref = Length::try_from(length)?;
+
+        let old_value_end = value_start.saturating_add(old_length);
+        let new_value_end = value_start.saturating_add(length);
+        self.data
+            .copy_within(old_value_end..end_index, new_value_end);
+        match old_length.cmp(&length) {
+            Ordering::Greater => {
+                // realloc to smaller, fill the end
+                let new_end_index = end_index.saturating_sub(old_length.saturating_sub(length));
+                self.data[new_end_index..end_index].fill(0);
+            }
+            Ordering::Less => {
+                // realloc to bigger, fill the moved part
+                self.data[old_value_end..new_value_end].fill(0);
+            }
+            Ordering::Equal => {} // nothing needed!
+        }
+
+        Ok(&mut self.data[value_start..new_value_end])
+    }
+}
+impl<'a> TlvState for TlvStateMut<'a> {
+    fn get_data(&self) -> &[u8] {
+        self.data
+    }
+}
+
+/// Get the base size required for TLV data
+const fn get_base_len() -> usize {
+    let indices = get_indices_unchecked(0);
+    indices.value_start
+}
+
+fn check_data(tlv_data: &[u8]) -> Result<(), ProgramError> {
+    // should be able to iterate through all entries in the TLV structure
+    let _ = get_discriminators_and_end_index(tlv_data)?;
+    Ok(())
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+    use bytemuck::{Pod, Zeroable};
+
+    const TEST_BUFFER: &[u8] = &[
+        1, 1, 1, 1, 1, 1, 1, 1, // discriminator
+        32, 0, 0, 0, // length
+        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+        1, 1, // value
+        0, 0, // empty, not enough for a discriminator
+    ];
+
+    const TEST_BIG_BUFFER: &[u8] = &[
+        1, 1, 1, 1, 1, 1, 1, 1, // discriminator
+        32, 0, 0, 0, // length
+        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+        1, 1, // value
+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+        0, // empty, but enough for a discriminator and empty value
+    ];
+
+    #[repr(C)]
+    #[derive(Clone, Copy, Debug, Default, PartialEq, Pod, Zeroable)]
+    struct TestValue {
+        data: [u8; 32],
+    }
+    impl TlvDiscriminator for TestValue {
+        const TLV_DISCRIMINATOR: Discriminator = Discriminator::new([1; Discriminator::LENGTH]);
+    }
+
+    #[repr(C)]
+    #[derive(Clone, Copy, Debug, Default, PartialEq, Pod, Zeroable)]
+    struct TestSmallValue {
+        data: [u8; 3],
+    }
+    impl TlvDiscriminator for TestSmallValue {
+        const TLV_DISCRIMINATOR: Discriminator = Discriminator::new([2; Discriminator::LENGTH]);
+    }
+
+    #[repr(transparent)]
+    #[derive(Clone, Copy, Debug, Default, PartialEq, Pod, Zeroable)]
+    struct TestEmptyValue;
+    impl TlvDiscriminator for TestEmptyValue {
+        const TLV_DISCRIMINATOR: Discriminator = Discriminator::new([3; Discriminator::LENGTH]);
+    }
+
+    #[repr(C)]
+    #[derive(Clone, Copy, Debug, PartialEq, Pod, Zeroable)]
+    struct TestNonZeroDefault {
+        data: [u8; 5],
+    }
+    const TEST_NON_ZERO_DEFAULT_DATA: [u8; 5] = [4; 5];
+    impl TlvDiscriminator for TestNonZeroDefault {
+        const TLV_DISCRIMINATOR: Discriminator = Discriminator::new([4; Discriminator::LENGTH]);
+    }
+    impl Default for TestNonZeroDefault {
+        fn default() -> Self {
+            Self {
+                data: TEST_NON_ZERO_DEFAULT_DATA,
+            }
+        }
+    }
+
+    #[test]
+    fn unpack_opaque_buffer() {
+        let state = TlvStateBorrowed::unpack(TEST_BUFFER).unwrap();
+        let value = state.get_value::<TestValue>().unwrap();
+        assert_eq!(value.data, [1; 32]);
+        assert_eq!(
+            state.get_value::<TestEmptyValue>(),
+            Err(ProgramError::InvalidAccountData)
+        );
+
+        let mut test_buffer = TEST_BUFFER.to_vec();
+        let state = TlvStateMut::unpack(&mut test_buffer).unwrap();
+        let value = state.get_value::<TestValue>().unwrap();
+        assert_eq!(value.data, [1; 32]);
+        let state = TlvStateOwned::unpack(test_buffer).unwrap();
+        let value = state.get_value::<TestValue>().unwrap();
+        assert_eq!(value.data, [1; 32]);
+    }
+
+    #[test]
+    fn fail_unpack_opaque_buffer() {
+        // input buffer too small
+        let mut buffer = vec![0, 3];
+        assert_eq!(
+            TlvStateBorrowed::unpack(&buffer),
+            Err(ProgramError::InvalidAccountData)
+        );
+        assert_eq!(
+            TlvStateMut::unpack(&mut buffer),
+            Err(ProgramError::InvalidAccountData)
+        );
+        assert_eq!(
+            TlvStateMut::unpack(&mut buffer),
+            Err(ProgramError::InvalidAccountData)
+        );
+
+        // tweak the discriminator
+        let mut buffer = TEST_BUFFER.to_vec();
+        buffer[0] += 1;
+        let state = TlvStateMut::unpack(&mut buffer).unwrap();
+        assert_eq!(
+            state.get_value::<TestValue>(),
+            Err(ProgramError::InvalidAccountData)
+        );
+
+        // tweak the length, too big
+        let mut buffer = TEST_BUFFER.to_vec();
+        buffer[Discriminator::LENGTH] += 10;
+        assert_eq!(
+            TlvStateMut::unpack(&mut buffer),
+            Err(ProgramError::InvalidAccountData)
+        );
+
+        // tweak the length, too small
+        let mut buffer = TEST_BIG_BUFFER.to_vec();
+        buffer[Discriminator::LENGTH] -= 1;
+        let state = TlvStateMut::unpack(&mut buffer).unwrap();
+        assert_eq!(
+            state.get_value::<TestValue>(),
+            Err(ProgramError::InvalidArgument)
+        );
+
+        // data buffer is too small for type
+        let buffer = &TEST_BUFFER[..TEST_BUFFER.len() - 5];
+        assert_eq!(
+            TlvStateBorrowed::unpack(buffer),
+            Err(ProgramError::InvalidAccountData)
+        );
+    }
+
+    #[test]
+    fn get_discriminators_with_opaque_buffer() {
+        // incorrect due to the length
+        assert_eq!(
+            get_discriminators_and_end_index(&[1, 0, 1, 1]).unwrap_err(),
+            ProgramError::InvalidAccountData,
+        );
+        // correct due to the good discriminator length and zero length
+        assert_eq!(
+            get_discriminators_and_end_index(&[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]).unwrap(),
+            (vec![Discriminator::try_from(1).unwrap()], 12)
+        );
+        // correct since it's just uninitialized data
+        assert_eq!(
+            get_discriminators_and_end_index(&[0, 0, 0, 0, 0, 0, 0, 0]).unwrap(),
+            (vec![], 0)
+        );
+    }
+
+    #[test]
+    fn value_pack_unpack() {
+        let account_size =
+            get_base_len() + size_of::<TestValue>() + get_base_len() + size_of::<TestSmallValue>();
+        let mut buffer = vec![0; account_size];
+
+        let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+
+        // success init and write value
+        let value = state.init_value::<TestValue>().unwrap();
+        let data = [100; 32];
+        value.data = data;
+        assert_eq!(
+            &state.get_discriminators().unwrap(),
+            &[TestValue::TLV_DISCRIMINATOR],
+        );
+        assert_eq!(&state.get_value::<TestValue>().unwrap().data, &data,);
+
+        // fail init extension when already initialized
+        assert_eq!(
+            state.init_value::<TestValue>().unwrap_err(),
+            TlvError::TypeAlreadyExists.into(),
+        );
+
+        // check raw buffer
+        let mut expect = vec![];
+        expect.extend_from_slice(TestValue::TLV_DISCRIMINATOR.as_ref());
+        expect.extend_from_slice(&u32::try_from(size_of::<TestValue>()).unwrap().to_le_bytes());
+        expect.extend_from_slice(&data);
+        expect.extend_from_slice(&[0; size_of::<Discriminator>()]);
+        expect.extend_from_slice(&[0; size_of::<Length>()]);
+        expect.extend_from_slice(&[0; size_of::<TestSmallValue>()]);
+        assert_eq!(expect, buffer);
+
+        // check unpacking
+        let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+        let mut unpacked = state.get_value_mut::<TestValue>().unwrap();
+        assert_eq!(*unpacked, TestValue { data });
+
+        // update extension
+        let new_data = [101; 32];
+        unpacked.data = new_data;
+
+        // check updates are propagated
+        let state = TlvStateBorrowed::unpack(&buffer).unwrap();
+        let unpacked = state.get_value::<TestValue>().unwrap();
+        assert_eq!(*unpacked, TestValue { data: new_data });
+
+        // check raw buffer
+        let mut expect = vec![];
+        expect.extend_from_slice(TestValue::TLV_DISCRIMINATOR.as_ref());
+        expect.extend_from_slice(&u32::try_from(size_of::<TestValue>()).unwrap().to_le_bytes());
+        expect.extend_from_slice(&new_data);
+        expect.extend_from_slice(&[0; size_of::<Discriminator>()]);
+        expect.extend_from_slice(&[0; size_of::<Length>()]);
+        expect.extend_from_slice(&[0; size_of::<TestSmallValue>()]);
+        assert_eq!(expect, buffer);
+
+        let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+        // init one more value
+        let new_value = state.init_value::<TestSmallValue>().unwrap();
+        let small_data = [102; 3];
+        new_value.data = small_data;
+
+        assert_eq!(
+            &state.get_discriminators().unwrap(),
+            &[
+                TestValue::TLV_DISCRIMINATOR,
+                TestSmallValue::TLV_DISCRIMINATOR
+            ]
+        );
+
+        // check raw buffer
+        let mut expect = vec![];
+        expect.extend_from_slice(TestValue::TLV_DISCRIMINATOR.as_ref());
+        expect.extend_from_slice(&u32::try_from(size_of::<TestValue>()).unwrap().to_le_bytes());
+        expect.extend_from_slice(&new_data);
+        expect.extend_from_slice(TestSmallValue::TLV_DISCRIMINATOR.as_ref());
+        expect.extend_from_slice(
+            &u32::try_from(size_of::<TestSmallValue>())
+                .unwrap()
+                .to_le_bytes(),
+        );
+        expect.extend_from_slice(&small_data);
+        assert_eq!(expect, buffer);
+
+        // fail to init one more extension that does not fit
+        let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+        assert_eq!(
+            state.init_value::<TestEmptyValue>(),
+            Err(ProgramError::InvalidAccountData),
+        );
+    }
+
+    #[test]
+    fn value_any_order() {
+        let account_size =
+            get_base_len() + size_of::<TestValue>() + get_base_len() + size_of::<TestSmallValue>();
+        let mut buffer = vec![0; account_size];
+
+        let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+
+        let data = [99; 32];
+        let small_data = [98; 3];
+
+        // write values
+        let value = state.init_value::<TestValue>().unwrap();
+        value.data = data;
+        let value = state.init_value::<TestSmallValue>().unwrap();
+        value.data = small_data;
+
+        assert_eq!(
+            &state.get_discriminators().unwrap(),
+            &[
+                TestValue::TLV_DISCRIMINATOR,
+                TestSmallValue::TLV_DISCRIMINATOR,
+            ]
+        );
+
+        // write values in a different order
+        let mut other_buffer = vec![0; account_size];
+        let mut state = TlvStateMut::unpack(&mut other_buffer).unwrap();
+
+        let value = state.init_value::<TestSmallValue>().unwrap();
+        value.data = small_data;
+        let value = state.init_value::<TestValue>().unwrap();
+        value.data = data;
+
+        assert_eq!(
+            &state.get_discriminators().unwrap(),
+            &[
+                TestSmallValue::TLV_DISCRIMINATOR,
+                TestValue::TLV_DISCRIMINATOR,
+            ]
+        );
+
+        // buffers are NOT the same because written in a different order
+        assert_ne!(buffer, other_buffer);
+        let state = TlvStateBorrowed::unpack(&buffer).unwrap();
+        let other_state = TlvStateBorrowed::unpack(&other_buffer).unwrap();
+
+        // BUT values are the same
+        assert_eq!(
+            state.get_value::<TestValue>().unwrap(),
+            other_state.get_value::<TestValue>().unwrap()
+        );
+        assert_eq!(
+            state.get_value::<TestSmallValue>().unwrap(),
+            other_state.get_value::<TestSmallValue>().unwrap()
+        );
+    }
+
+    #[test]
+    fn init_nonzero_default() {
+        let account_size = get_base_len() + size_of::<TestNonZeroDefault>();
+        let mut buffer = vec![0; account_size];
+        let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+        let value = state.init_value::<TestNonZeroDefault>().unwrap();
+        assert_eq!(value.data, TEST_NON_ZERO_DEFAULT_DATA);
+    }
+
+    #[test]
+    fn init_buffer_too_small() {
+        let account_size = get_base_len() + size_of::<TestValue>();
+        let mut buffer = vec![0; account_size - 1];
+        let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+        let err = state.init_value::<TestValue>().unwrap_err();
+        assert_eq!(err, ProgramError::InvalidAccountData);
+
+        // hack the buffer to look like it was initialized, still fails
+        let discriminator_ref = &mut state.data[0..Discriminator::LENGTH];
+        discriminator_ref.copy_from_slice(TestValue::TLV_DISCRIMINATOR.as_ref());
+        state.data[Discriminator::LENGTH] = 32;
+        let err = state.get_value::<TestValue>().unwrap_err();
+        assert_eq!(err, ProgramError::InvalidAccountData);
+        assert_eq!(
+            state.get_discriminators().unwrap_err(),
+            ProgramError::InvalidAccountData
+        );
+    }
+
+    #[test]
+    fn value_with_no_data() {
+        let account_size = get_base_len() + size_of::<TestEmptyValue>();
+        let mut buffer = vec![0; account_size];
+        let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+
+        assert_eq!(
+            state.get_value::<TestEmptyValue>().unwrap_err(),
+            TlvError::TypeNotFound.into(),
+        );
+
+        state.init_value::<TestEmptyValue>().unwrap();
+        state.get_value::<TestEmptyValue>().unwrap();
+
+        // re-init fails
+        assert_eq!(
+            state.init_value::<TestEmptyValue>().unwrap_err(),
+            TlvError::TypeAlreadyExists.into(),
+        );
+    }
+
+    #[test]
+    fn alloc() {
+        let tlv_size = 1;
+        let account_size = get_base_len() + tlv_size;
+        let mut buffer = vec![0; account_size];
+        let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+
+        // not enough room
+        let data = state.alloc::<TestValue>(tlv_size).unwrap();
+        assert_eq!(
+            pod_from_bytes_mut::<TestValue>(data).unwrap_err(),
+            ProgramError::InvalidArgument,
+        );
+
+        // can't double alloc
+        assert_eq!(
+            state.alloc::<TestValue>(tlv_size).unwrap_err(),
+            TlvError::TypeAlreadyExists.into(),
+        );
+    }
+
+    #[test]
+    fn realloc() {
+        const TLV_SIZE: usize = 10;
+        const EXTRA_SPACE: usize = 5;
+        const SMALL_SIZE: usize = 2;
+        const ACCOUNT_SIZE: usize = get_base_len()
+            + TLV_SIZE
+            + EXTRA_SPACE
+            + get_base_len()
+            + size_of::<TestNonZeroDefault>();
+        let mut buffer = vec![0; ACCOUNT_SIZE];
+        let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+
+        // alloc both types
+        let _ = state.alloc::<TestValue>(TLV_SIZE).unwrap();
+        let _ = state.init_value::<TestNonZeroDefault>().unwrap();
+
+        // realloc first entry to larger, all 0
+        let data = state.realloc::<TestValue>(TLV_SIZE + EXTRA_SPACE).unwrap();
+        assert_eq!(data, [0; TLV_SIZE + EXTRA_SPACE]);
+        let value = state.get_value::<TestNonZeroDefault>().unwrap();
+        assert_eq!(*value, TestNonZeroDefault::default());
+
+        // realloc to smaller, still all 0
+        let data = state.realloc::<TestValue>(SMALL_SIZE).unwrap();
+        assert_eq!(data, [0; SMALL_SIZE]);
+        let value = state.get_value::<TestNonZeroDefault>().unwrap();
+        assert_eq!(*value, TestNonZeroDefault::default());
+        let (_, end_index) = get_discriminators_and_end_index(&buffer).unwrap();
+        assert_eq!(
+            &buffer[end_index..ACCOUNT_SIZE],
+            [0; TLV_SIZE + EXTRA_SPACE - SMALL_SIZE]
+        );
+
+        // unpack again since we dropped the last `state`
+        let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+        // realloc too much, fails
+        assert_eq!(
+            state
+                .realloc::<TestValue>(TLV_SIZE + EXTRA_SPACE + 1)
+                .unwrap_err(),
+            ProgramError::InvalidAccountData,
+        );
+    }
+}
+#[cfg(all(test, feature = "borsh"))]
+mod borsh_test {
+    use super::*;
+    #[derive(Clone, Debug, PartialEq, borsh::BorshDeserialize, borsh::BorshSerialize)]
+    struct TestBorsh {
+        data: String, // test with a variable length type
+        inner: TestInnerBorsh,
+    }
+    #[derive(Clone, Debug, PartialEq, borsh::BorshDeserialize, borsh::BorshSerialize)]
+    struct TestInnerBorsh {
+        data: String,
+    }
+    impl TlvDiscriminator for TestBorsh {
+        const TLV_DISCRIMINATOR: Discriminator = Discriminator::new([5; Discriminator::LENGTH]);
+    }
+    #[test]
+    fn borsh_value() {
+        let initial_data = "This is a pretty cool test!";
+        let initial_inner_data = "And it gets even cooler!";
+        // exactly the right size
+        let tlv_size = 4 + initial_data.len() + 4 + initial_inner_data.len();
+        let account_size = get_base_len() + tlv_size;
+        let mut buffer = vec![0; account_size];
+        let mut state = TlvStateMut::unpack(&mut buffer).unwrap();
+
+        // don't actually need to hold onto the data!
+        let _ = state.alloc::<TestBorsh>(tlv_size).unwrap();
+        let test_borsh = TestBorsh {
+            data: initial_data.to_string(),
+            inner: TestInnerBorsh {
+                data: initial_inner_data.to_string(),
+            },
+        };
+        state.borsh_serialize(&test_borsh).unwrap();
+        let deser = state.borsh_deserialize::<TestBorsh>().unwrap();
+        assert_eq!(deser, test_borsh);
+
+        // writing too much data fails
+        let too_much_data = "This is a pretty cool test!?";
+        assert_eq!(
+            state
+                .borsh_serialize(&TestBorsh {
+                    data: too_much_data.to_string(),
+                    inner: TestInnerBorsh {
+                        data: initial_inner_data.to_string(),
+                    }
+                })
+                .unwrap_err(),
+            ProgramError::BorshIoError("failed to write whole buffer".to_string()),
+        );
+    }
+}
